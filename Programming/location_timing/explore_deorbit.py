# explore_deorbit.py
# make some nice plots to visualize deorbit stuff

# it runs on data files generated by change_initcond.py, which should be put in Simulations/

import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')

import findjuliandates


NUM_ORBITS = 6
NUM_SIMS = 30

SOURCE_DIR = '../../Simulations/'

DAY_LENGTH_THRESH = datetime.timedelta(seconds=60) # no day is this short
NIGHT_LENGTH_THRESH = datetime.timedelta(seconds=60) # no night is this short


if __name__ == '__main__':
	num_orbits = np.empty((NUM_SIMS, 1))
	night_lengths = np.empty((NUM_SIMS, NUM_ORBITS))
	orbit_lengths = np.empty((NUM_SIMS, NUM_ORBITS))

	for i in range(0, NUM_SIMS):
		with open('{:s}SunriseSunset_d{:02d}_{:03d}.txt'.format(SOURCE_DIR, 0, i), 'r') as f:
			lines = f.readlines()
		epoch = findjuliandates.utc_to_datetime(' '.join(lines[3].split()[0:4]))
		type_names = [line.split()[-3] for line in lines[3:-7]]
		start_times = [findjuliandates.utc_to_seconds(' '.join(line.split()[0:4]), epoch) for line in lines[3:-7]]
		stop_times = [findjuliandates.utc_to_seconds(' '.join(line.split()[4:8]), epoch) for line in lines[3:-7]]

		for j in reversed(range(1, len(type_names))): # correct weird double-umbra events
			if type_names[j] == type_names[j-1] and start_times[j] - stop_times[j-1] < DAY_LENGTH_THRESH.total_seconds():
				type_names.pop(j)
				stop_times.pop(j-1)
				start_times.pop(j)
		for j in reversed(range(0, len(type_names))): # and weird extra umbra events
			if type_names[j] == 'Umbra' and stop_times[j] - start_times[j] < NIGHT_LENGTH_THRESH.total_seconds():
				type_names.pop(j)
				stop_times.pop(j)
				start_times.pop(j)

		set_times = [st for st, tn in zip(start_times, type_names) if tn=='Umbra'] # measure sunwend times for each orbit in this simulation
		rise_times = [st for st, tn in zip(stop_times, type_names) if tn == 'Umbra']
		for j in range(-1, -1-NUM_ORBITS, -1):
			orbit_lengths[i,j] = set_times[j] - set_times[j-1]
			night_lengths[i,j] = rise_times[j-1] - set_times[j-1] if rise_times[j-1] > set_times[j-1] else rise_times[j] - set_times[j-1]
		num_orbits[i,0] = len(set_times)

	day_lengths = orbit_lengths - night_lengths
	orbit_deltas = orbit_lengths[:,1:] - orbit_lengths[:,:-1]
	orbit_decays = orbit_deltas/orbit_lengths[:,:-1]

	# sns.set_palette(sns.cubehelix_palette(NUM_ORBITS-1, start=.15, rot=-1, light=.7, dark=.2, reverse=True))
	for j in range(-1, -NUM_ORBITS, -1): # go from the back and skip any extras at the end
		label = (-j-2)*"ante"+"penultimate" if j < -1 else "final"
		plt.scatter(orbit_lengths[:,j]/60, day_lengths[:,j]/60, s=10, label=label.capitalize())
	plt.xlabel("Orbit length (min)")
	plt.ylabel("Orbit decay rate (%)")
	plt.legend()
	plt.show()
